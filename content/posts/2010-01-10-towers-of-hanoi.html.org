---
title: "Towers of Hanoi"
date: "2010-01-10"
tags:
- pedagogy
draft: false
---

<div class="figure"><div class="separator" style="clear: both; text-align: center;"><a href="http://3.bp.blogspot.com/_7YN3bkG0cSc/S0pFwojEDmI/AAAAAAAAFa8/WMWXtwK6nxo/s1600-h/Hanoi.jpg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://3.bp.blogspot.com/_7YN3bkG0cSc/S0pFwojEDmI/AAAAAAAAFa8/WMWXtwK6nxo/s320/Hanoi.jpg" /></a><br /></div><br /></div>Closed out last week teaching the <a href="http://www.cut-the-knot.org/recurrence/hanoi.shtml">Towers of Hanoi</a>. It's a wonderful topic. Not because it's so interesting in and of itself, but as a platform from which you can explore any number of interesting topics.<br /><br />Many books appropriate for the AP (AB) curriculum mention the towers, but to my knowledge most only scratch the surface. I randomly grabbed two books that I consider good from the shelf before writing this. One that I actually use when I teach AP comp sci and another more appropriate for a follow up course. Both discuss the towers, but merely show a solution and talk about the run time a little.<br /><br />So many possibilities left out. <br /><br />I usually do these lessons with my sophomores but since many of my AP students (juniors) hadn't ever seened the problem, I felt it was worth covering. <br /><br />By looking at a few small examples, 1 disk, two disks, three disks, four disks, it's easy to notice the symetry in the solutions ultimately leading the this short routine: <br /><pre class="src src-java">&nbsp;</pre><pre class="src src-java"> 1:  hanoi(n,src,dst,tmp) {<br /> 2:    <span style="color: #a020f0;">if</span> (n==1)<br /> 3:      System.out.println(<span style="color: #8b2252;">"Move from "</span>+src+<span style="color: #8b2252;">" to "</span>+dst);<br /> 4:    <span style="color: #a020f0;">else</span><br /> 5:    {<br /> 6:      hanoi(n-1,src,tmp.dst);<br /> 7:      hanoi(1,src,dst,tmp);<br /> 8:      hanoi(n-1,tmp,dst,src);<br /> 9:    }<br />10:  }  <br /></pre><br />Now, the fun can really start: <br /><br />We want to talk about the correctness of our algorithm and also how many moves it will take, that is, the run time. First, we'll use inductive ideas to show our algorithm is correct. This "proof" (we do it somewhat informally) can be enlightening. As sophomores, the only proofs students have seen are those statement/reason things they do in math class. Here we can introduce them to the idea that proof is just an "irrefutable argument" and apply it in a more practical setting. <br /><br />From there we look at run time, that is, how many moves will it take to solve the n disk problem. It's easy to see the pattern of T(N) = 2T(n-1)+1 . Students will usually see that we can rewrite this as T(N)=2<sup>N</sup>-1 which we can also prove by induction.<br /><br />Now we can see the ramifications of the run time. At 1 million moves per second, it works out to close to 600,000 years. This in and of itself is revealing, we can't just "get a faster computer."  Here we can discuss <a href="http://en.wikipedia.org/wiki/Moore%27s_law">Moore's Law</a> and the physical limits on our computers, making sure to make appropriate reference to <a href="http://en.wikipedia.org/wiki/Grace_Hopper">Grace Hopper</a> and her <a href="http://www.flickr.com/photos/shinythings/154816771/">nanosecond</a>. <br /><br />This leads to a discussion alternate approaches such as parallel processing, but that doesn't work if our problem can only be solved sequentially.<br /><br />The rest of the class is used discussing other hard problems and other approaches including heuristics, probabalistic, randomized, and anything else that comes up. <br /><br />So, there you have it. From this one simple problem we get to introduce students to: <br /><br /><ul><li id="sec-1">Alternate forms of proof (specificall induction) <br /></li><li id="sec-2">Intractable problems <br /></li><li id="sec-3">Unsolvable problem <br /></li><li id="sec-4">Moores law and the limits of our computing power <br /></li><li id="sec-5">Alternate approaches to computing &nbsp; <br /><br /><br /><ul><li id="sec-5">Parallel programming <br /></li><li id="sec-5.2">Protein based computers <br /></li><li id="sec-5.3">Randomized algorithms <br /></li><li id="sec-5.4">Probabalistic algorithms <br /></li><li id="sec-5.5">Heuristics</li></ul><br /></li></ul><div class="blogger-post-footer"><img width='1' height='1' src='https://blogger.googleusercontent.com/tracker/468689896075458340-6512019415176840666?l=cestlaz.blogspot.com' alt='' /></div>
