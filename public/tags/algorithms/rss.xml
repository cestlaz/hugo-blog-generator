<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>algorithms on C&#39;est la Z</title>
    <link>https://cestlaz.github.io/tags/algorithms/</link>
    <description>C&#39;est la Z (algorithms)</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 26 Jan 2020 13:10:47 -0400</lastBuildDate>
    
    <atom:link href="https://cestlaz.github.io/tags/algorithms/rss.xml" rel="self" type="application/rss" />
    
    
    <item>
      <title>Sorting by hand or searching and inserting</title>
      <link>https://cestlaz.github.io/post/sorting-by-hand/</link>
      <pubDate>Sun, 26 Jan 2020 13:10:47 -0400</pubDate>
      
      <guid>https://cestlaz.github.io/post/sorting-by-hand/</guid>
      <description>&lt;script type=&#34;text/javascript&#34;
  src=&#34;https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML&#34;&gt;
&lt;/script&gt;
&lt;p&gt;
Natan commenting on work the  other day:
&lt;/p&gt;
&lt;blockquote&gt;

&#34;You have two lists. One is sorted, the other is not. Every item in
one list corresponds to an item in the other. Is it faster to sort the
unsorted list and then merge them, or simply go through the unsorted
list in order and pair each item with the item you can find in the
presorted list?&#34; is a question I asked today in the dressing room of
an off-Broadway theater. I&#39;ve used RegEx at my job before, but I never
thought Big O notation would become relevant!

Let this be submitted as evidence that a computer science education is
valuable no matter what field you go into. That, or I&#39;m just a
particular kind of crazy.
&lt;/blockquote&gt;
&lt;p&gt;
There&amp;#39;s clearly an unplugged activity here :-)
&lt;/p&gt;
&lt;p&gt;
As a programming exercise, it&amp;#39;s pretty easy to analyze. Since one list
is sorted, you can use a binary search for each insertion. That&amp;#39;s \( n \)
searches of \(lgn\) each yields an \( nlogn \)  run time. Of course,
if the sorted list is an array and you have to shift all the elements
down in linear time for each insert, that changes things.
&lt;/p&gt;
&lt;p&gt;
Sorting first is also \(nlogn\). Use an \(nlogn\) sort and then merge
the two lists which is linear. Here though, you will also either have
to ultimately do the shifting for insertions or use extra space by
making an new array or list for the two merged sets.
&lt;/p&gt;
&lt;p&gt;
The interesting discussion points here are the issues like in place
vs not and the extra time needed for the shifts.
&lt;/p&gt;
&lt;p&gt;
Unplugged though allows for even richer discussion.
&lt;/p&gt;
&lt;p&gt;
Having humans step through computer algorithms can be popular
activities at times and they can also be very instructive but as
humans, we&amp;#39;re not optimized the same ways computers are. While we
might perform some tasks using set algorithms and those algorithms
might be the same as on a computer, more often than not, they&amp;#39;re
different - at least at a higher thought level.
&lt;/p&gt;
&lt;p&gt;
Let&amp;#39;s take the insertion solution to our problem. Code wise, we&amp;#39;d use
a binary search. Humans however don&amp;#39;t use binary search. If we did, it
would actually be pretty inefficient.  We&amp;#39;d have to locate the exact
middle which would probably require specific counting and already
we&amp;#39;ve used linear time. Even if we guessed the first middle correctly,
each additional split would require we find a new middle and again,
realistically, each time we&amp;#39;d count - more linear components.
&lt;/p&gt;
&lt;p&gt;
In reality, we&amp;#39;d probably use a guided type search. The specific
problem involved inserting letters from an unsorted pile into
envelopes in a sorted pile so we&amp;#39;d jump down in the envelope pile by a
guess amount based on the letter we&amp;#39;re looking for - Last name Tucker,
we&amp;#39;d jump close to the end. For Davis, near the front. If we ended up
far off, we&amp;#39;d jump again, if not, we&amp;#39;d rifle through one by one for
the insertion point. There are similarities to a binary search but
it&amp;#39;s a very different algorithm. We couldn&amp;#39;t easily code up our guided
search as we have an intuitive instant ability to decide where to jump
to and when to jump but on the other hand we&amp;#39;re slower if we use the
proven \(logn\) binary search.
&lt;/p&gt;
&lt;p&gt;
Sorting is similar. On the computer we&amp;#39;d probably use our langauges
built in sort which would be \(nlogn\). By hand, we&amp;#39;d probably use
some sort of bucket sort with merging in the individual piles. Even if
we were sorting continuous values as opposed to discrete ones like
names, we&amp;#39;d probably use buckets. 
&lt;/p&gt;
&lt;p&gt;
All of this can lead to very rich discussion - how we do things vs how
the computer does and even more, how we decide how to do things. Maybe
with a small data set we don&amp;#39;t even do a bucket sort but more of an
insertion or selection type sort. How do we decide what our jumps our
when we&amp;#39;re searching by hand or our bucket demarcations when sorting?
&lt;/p&gt;
&lt;p&gt;
Lots of good stuff here, all because somebody at Natan&amp;#39;s job forgot to
sort the letters before they printed them out.
&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Grokking Algorithms</title>
      <link>https://cestlaz.github.io/post/grokking-algorithms/</link>
      <pubDate>Tue, 11 Jun 2019 07:29:30 -0400</pubDate>
      
      <guid>https://cestlaz.github.io/post/grokking-algorithms/</guid>
      <description>&lt;p&gt;
Someone mentioned &lt;a href=&#34;https://www.manning.com/books/grokking-algorithms&#34;&gt;Grokking Algorithms&lt;/a&gt; by Aditya Y. Bhargava in one of
the CS educator Facbeook groups. It looked interesting so I thought
I&amp;#39;d give it a once over.
&lt;/p&gt;
&lt;p&gt;
It&amp;#39;s certainly an accessible book. Text mixed with cute line drawings,
&amp;#34;hand written&amp;#34; text, diagrams and picture.s It reminded me of one of
my favorite, most accessible  Calculus books &lt;a href=&#34;https://www.goodreads.com/book/show/706622.Who_Is_Fourier_a_Mathematical_Adventure&#34;&gt;Who Was Fourier&lt;/a&gt;.
&lt;/p&gt;
&lt;p&gt;
Overall I enjoyed the book but I&amp;#39;m not sure what its best audience
is. If you look at the selection of topics, it&amp;#39;s a little
haphazard. It introduces Big-O notation, sescrion sort, and intro
recursion all of which are covered prior to an algorithms course. It
also introduces linked lists in what I felt was an early and arbitrary
place but then neither gave any more than a theoretical overview nor
came back to them later. On the other hand, when the author covers
QuickSort he at one point compares it to a MergeSort as if that were
covered as well. On the more advanced side, there are Hash Tables,
Dijkstra&amp;#39;s Aalgorithm, Dyanmic Programming, and a few teasers at the
end.
&lt;/p&gt;
&lt;p&gt;
The biggest downside of the book, to me, is that some of the topics
seem to be great explanations of things as long as you already know
them. The Linked List coverage is a great example of this. The author
does a nice job relating Linked Lists to memory and how they are
theoretically implemented under the hood. That said, unless you&amp;#39;ve
already studied linked lists it probably isn&amp;#39;t enough to go
anywhere. This might be fine if you are to assume that the reader has
already taken data structures but if that&amp;#39;s the case, the linked list
section is probably superflous.
&lt;/p&gt;
&lt;p&gt;
Another point I noted was that some of the coverage is pretty standard
but some is great. I wasn&amp;#39;t very impressed by the recursion chapter
nor the coverage of Dijkstra&amp;#39;s algorithm. They were fine but nothing
special. On the other hand, I very much liked the way Bhargava laid
out and discussed Dynamic Programming. To me, that section alone is probably
worth the book. I don&amp;#39;t think it&amp;#39;s enough for you to build a unit on
Dyanamic Programming but the author provides a great way of developing
and talking about the subject and gives some nice examples. I also
like the way it builds from Greedy Algorithms.
&lt;/p&gt;
&lt;p&gt;
To be fair, I read a couple of Amazon Reviews of the book and one
reviewer loved the coverage of  Dijkstra&amp;#39;s algorithm so there is a lot
of subjectivity here. 
&lt;/p&gt;
&lt;p&gt;
A couple of other minor points worth thinking about are math and
rigor. One of the quotes on the back of the book states:
&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;
This book does the impossible: it makes math fun and easy!
&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;
I&amp;#39;ve got to disagree with this. The book doesn&amp;#39;t take any
traditionally difficult math and magically make it trivial. Rather the
book has some examples where basic math can be used to great
effect. In one section, Bhargava talks about classifiers and
similarity scores using the Distance Formula. It&amp;#39;s somewhat similar to
what I do &lt;a href=&#34;https://cestlaz.github.io/posts/2014-01-07-rot13-gateway/&#34;&gt;here&lt;/a&gt;. He&amp;#39;s not making hard math easy but rather he&amp;#39;s showing
that basic math can be amazingly useful and you can do cool and
powerful things with it. Nothing wrong with that. It&amp;#39;s a great thing
to do but it&amp;#39;s not making hard math easy. The author also refers the
reader to external references for more.
&lt;/p&gt;
&lt;p&gt;
The other point I want to mention is rigor - this is bound to come up
whenever a book tries to be accessible. While it&amp;#39;s true that the author
seems to fudge or simplify a definition here and there I didn&amp;#39;t find
any major problems and think that his choices in terms of langauge,
rigor, and fudge factor  are generally appropriate.
&lt;/p&gt;
&lt;p&gt;
So bottom line - who is this book for and should you get it?
&lt;/p&gt;
&lt;p&gt;
This is not a standalone algorithms book. You couldn&amp;#39;t use it for a
class by that name. The book mentions that it could be useful to a
code school graduate and given the lack of consistency in what&amp;#39;s
covered in code schools that&amp;#39;s probably a good recommendation. It
gives some feel and flavor on a number of subjects, does nothing
poorly and while it omits things that might be necessary, it does many
things well.
&lt;/p&gt;
&lt;p&gt;
To me, this is an ideal book as resource for a teacher looking to
stretch their APCS-A or APCS-AB class or possibly for an advanced
student.
&lt;/p&gt;
&lt;p&gt;
I enjoyed the book. You probably will too.
&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Seam Carving and Dynamic Programming</title>
      <link>https://cestlaz.github.io/post/seam-carving/</link>
      <pubDate>Mon, 22 Apr 2019 13:51:52 -0400</pubDate>
      
      <guid>https://cestlaz.github.io/post/seam-carving/</guid>
      <description>&lt;p&gt;
It&amp;#39;s spring break and for me that&amp;#39;s always been a good time to explore
some new ideas.
&lt;/p&gt;
&lt;p&gt;
Here&amp;#39;s one that some of you might like, particularly if you&amp;#39;re
teaching APCS-A or something similar. 
&lt;/p&gt;
&lt;p&gt;
Many APCS-A teachers do a unit on image processing using the &lt;a href=&#34;https://docs.google.com/viewer?url=http%253A%252F%252Fmedia.collegeboard.com%252FdigitalServices%252Fpdf%252Fap%252Fpicture-lab-studentguide.pdf%0A&#34;&gt;picture
lab&lt;/a&gt; (&lt;a href=&#34;http://www.apcs.mathorama.com/index.php?n=Main.PictureLab&#34;&gt;alternate resource&lt;/a&gt;). Image processing is a nice platform to
explore two dimensional arrays. You basically use a 2D array of pixels
(points) to represent an image. You can just use a 2D array of ints
and store 0-255 at each location for a grayscale image and three ints
per pixel for red, green, blue. For this you can just use a simple
2D array of some color class - I think there&amp;#39;s even one built into
Java that you can use.
&lt;/p&gt;
&lt;p&gt;
I like to use the PPM format to save and later reload the images. PPM
is a simple text format. It starts with a header, then an optional
comment (starting with #), the width and height (4x4 in the example
below), then the maximum color number. Here&amp;#39;s an example:
&lt;/p&gt;
&lt;pre class=&#34;example&#34;&gt;
P3
# feep.ppm
4 4
15
 0  0  0    0  0  0    0  0  0   15  0 15
 0  0  0    0 15  7    0  0  0    0  0  0
 0  0  0    0  0  0    0 15  7    0  0  0
15  0 15    0  0  0    0  0  0    0  0  0
&lt;/pre&gt;
&lt;p&gt;
You can even cut and paste the above into a file and view it with an
image viewer. 
&lt;/p&gt;
&lt;p&gt;
You can find the full format specification &lt;a href=&#34;http://netpbm.sourceforge.net/doc/ppm.html%0A&#34;&gt;here&lt;/a&gt; (&lt;a href=&#34;https://en.wikipedia.org/wiki/Netpbm_format&#34;&gt;alternate resource&lt;/a&gt;). 
&lt;/p&gt;
&lt;p&gt;
The picture lab has a bunch of interesting exercise ideas but if
you&amp;#39;re looking for something &amp;#34;next level&amp;#34; check this out:
&lt;/p&gt;
&lt;p&gt;
&amp;lt;iframe width=&amp;#34;560&amp;#34; height=&amp;#34;315&amp;#34;
src=&amp;#34;&lt;a href=&#34;https://www.youtube.com/embed/6NcIJXTlugc&#34;&gt;https://www.youtube.com/embed/6NcIJXTlugc&lt;/a&gt;&amp;#34; frameborder=&amp;#34;0&amp;#34;
allow=&amp;#34;accelerometer; autoplay; encrypted-media; gyroscope;
picture-in-picture&amp;#34; allowfullscreen&amp;gt;&amp;lt;/iframe&amp;gt;
&lt;/p&gt;
&lt;p&gt;
Seam Carving is no longer a new cutting edge
technique but it still blows me away. It&amp;#39;s also a really cool project
for more advanced students for two reasons: one, it&amp;#39;s not a toy
assignment - it&amp;#39;s from real research and two, it contains a very
approachable example of dynamic programming which I&amp;#39;ll talk about in a
bit.
&lt;/p&gt;
&lt;p&gt;
If you watch the video, there are two pieces that can sound
intimidating. One is the &amp;#34;dynamic programming algorithm.&amp;#34; The other is
when they talk about the &amp;#34;gradient magnitude.&amp;#34; 
&lt;/p&gt;
&lt;p&gt;
Gradient magnitude. That sounds pretty hard. Actually, it could be
worse. When I first starting looking at the basics of image processing
it was described as &amp;#34;the derivative of the pixels.&amp;#34; &lt;strong&gt;The dirivative of
the pixels????&lt;/strong&gt; I have to know calculus for this?????? Not really. I
hate it when they use big words for simple ideas. All they&amp;#39;re really
talking about is the difference between the color of neighboring
pixels. That is, how much the color changes from one pixel to the
next. Let&amp;#39;s say you have a greyscale image (or have converted an image
to greyscale by averaging the red green and blue values), if you have
a vertical row of pixels with all the values of, let&amp;#39;s say 200 and the
row right next to it is also of values 200, then the two lines are of
the same color - there is no difference. If one pixel has a value of
200 and its neighbor has a value of 50, it changes quite a lot.
&lt;/p&gt;
&lt;p&gt;
The APCS-A picture lab describes a simple way to calculate this in
exercise 9 (linked above). You can also just do a search on &amp;#34;edge
detection tutorial&amp;#34; or &amp;#34;sobol edge detection tutorial&amp;#34; or something
similar.
&lt;/p&gt;
&lt;p&gt;
For Seam Carving, you have to find a sequence of pixels from one side
of the image to the other where the sum off all the differences is the
lowest. This is where the dynamic programming comes in.
&lt;/p&gt;
&lt;p&gt;
&lt;a href=&#34;https://en.wikipedia.org/wiki/Dynamic_programming&#34;&gt;Dynamic Programming&lt;/a&gt; is a technique that, in basic terms takes a
problem that decomposes into subproblems and you store the optimal
subproblem solution rather than recalculating it.
&lt;/p&gt;
&lt;p&gt;
Probably the easiest example is Fibonacci numbers. You can generate
Fibonacci numbers recursively using something like this:
&lt;/p&gt;
&lt;div class=&#34;src src-python&#34;&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;fib&lt;/span&gt;(n):
      &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; n&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;:
          &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
      &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt;:
          &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; fib(n&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;)&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;fib(n&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;
It&amp;#39;s very simple but it gets very slow very fast. That&amp;#39;s because it
keeps recalculating the same subproblems over and over and over.
&lt;/p&gt;
&lt;p&gt;
You can &amp;#34;fix&amp;#34; this by creating a list of previously found Fibonacci 
numbers and just return them rather than recalculating:
&lt;/p&gt;
&lt;div class=&#34;src src-python&#34;&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;  fibs &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; [&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;]&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1000&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;# make room for 1000 fib numbers&lt;/span&gt;

  &lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;fib&lt;/span&gt;(n):
      &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; fibs[n] &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;:
          &lt;span style=&#34;color:#75715e&#34;&gt;# we already have the answer, just return it&lt;/span&gt;
          &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; fibs[n]
      &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt;:
          &lt;span style=&#34;color:#75715e&#34;&gt;# otherwise, calculate it, store it, return it&lt;/span&gt;
          f &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; fib(n&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;)&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;fib(n&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;)
          fibs[n]&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;f
          &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; f&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;
and that&amp;#39;s a dynamic programming solution for Fibonacci numbers,
specifically using a technique known as &lt;a href=&#34;https://en.wikipedia.org/wiki/Memoization&#34;&gt;memoization&lt;/a&gt;.  
&lt;/p&gt;
&lt;p&gt;
How does this apply to finding the proper seam to remove? The one with
the lowest total change? 
&lt;/p&gt;
&lt;p&gt;
First, go through the image array and build a second 2D array where
each element contains the pixels &amp;#34;gradient magnitude&amp;#34; or change using
either the method described in task 9 of the picture lab or
elsewhere. 
&lt;/p&gt;
&lt;p&gt;
For the first row, the sum of each pixels path so far is just the
array element.
&lt;/p&gt;
&lt;p&gt;
For each successive row, the value of any pixel is going to be it&amp;#39;s
value plus one of the values abov it, either up left, up center, or up
right. Specifically, the elements new value will be it&amp;#39;s value + the
smallest of the above three.
&lt;/p&gt;
&lt;p&gt;
For example, given this array representing the color changes:
&lt;/p&gt;
&lt;p&gt;
&amp;lt;figure class=&amp;#34;z_image_center&amp;#34;&amp;gt;
    &amp;lt;img src=&amp;#34;/img/seam-mat1.png&amp;#34;/&amp;gt; 
&amp;lt;/figure&amp;gt;
&lt;/p&gt;
&lt;p&gt;
When calculating the second item in the second row, you&amp;#39;ll consider
the three values above it:
&lt;/p&gt;
&lt;p&gt;
&amp;lt;figure class=&amp;#34;z_image_center&amp;#34;&amp;gt;
    &amp;lt;img src=&amp;#34;/img/seam-mat2.png&amp;#34;/&amp;gt; 
&amp;lt;/figure&amp;gt;
&lt;/p&gt;
&lt;p&gt;
The smallest is 0 so that 2 remains a 2. If we do this for every
element in the second row we get the following:
&lt;/p&gt;
&lt;p&gt;
&amp;lt;figure class=&amp;#34;z_image_center&amp;#34;&amp;gt;
    &amp;lt;img src=&amp;#34;/img/seam-mat3.png&amp;#34;/&amp;gt; 
&amp;lt;/figure&amp;gt;
&lt;/p&gt;
&lt;p&gt;
The green boxes added a 0 from the line above but the yellow ones
added the smallest non zero value from the above  row. Note that the
edges just considered the two values above them and didn&amp;#39;t wrap.
&lt;/p&gt;
&lt;p&gt;
Working the rest of the way through, you get this final array:
&lt;/p&gt;
&lt;p&gt;
&amp;lt;figure class=&amp;#34;z_image_center&amp;#34;&amp;gt;
    &amp;lt;img src=&amp;#34;/img/seam-mat4.png&amp;#34;/&amp;gt; 
&amp;lt;/figure&amp;gt;
&lt;/p&gt;
&lt;p&gt;
You can now easily identify the best seam to remove by finding the
smallest value in the bottom row and working your way up to the top.
&lt;/p&gt;
&lt;p&gt;
All together this is very doable by an advanced APCS-A student and the
results are very cool, particularly if you do it in an interactive
environment like processing.
&lt;/p&gt;
&lt;p&gt;
So, check out seam carving. I&amp;#39;ll leave you with one more link to a
longer presentation on the topic: 
&lt;/p&gt;
&lt;p&gt;
&lt;a href=&#34;https://www.youtube.com/watch?v=ZBtXl3EuU14&#34;&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=ZBtXl3EuU14&#34;&gt;https://www.youtube.com/watch?v=ZBtXl3EuU14&lt;/a&gt;&lt;/a&gt;
&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Teaching Sorting</title>
      <link>https://cestlaz.github.io/post/teaching-sorting/</link>
      <pubDate>Mon, 19 Nov 2018 20:04:08 -0400</pubDate>
      
      <guid>https://cestlaz.github.io/post/teaching-sorting/</guid>
      <description>&lt;p&gt;
Earlier today I saw a facebook post asking for thoughts on teaching
sorting. The question was specifically not  about motivations like
having the class act out sorts or sort cards but rather about the
coding. 
&lt;/p&gt;
&lt;p&gt;
I&amp;#39;ve been meaning to write about this since last summer when I
attended Owen Astrachan&amp;#39;s talk on the same subject.
&lt;/p&gt;
&lt;p&gt;
Early in my career when teaching sorting I developed the n^2 sorts as
standalone routines just as they&amp;#39;re presented in most books but as I
gained more experience as a teacher, I changed it up to build the
sorts (at least some of them) from existing concepts. 
&lt;/p&gt;
&lt;p&gt;
Let&amp;#39;s look at the selection sort.
&lt;/p&gt;
&lt;p&gt;
We can demonstrate it by arranging an already dealt hand. Find the
smallest card place it all the way at the left. The next smallest,
next to it. Repeat until done.
&lt;/p&gt;
&lt;p&gt;
This is actually a very easy algorithm to develop using code the kids
have already written.
&lt;/p&gt;
&lt;p&gt;
By the time we do sorting, students have already written the code to
find the smallest or largest in a list time and time again. We&amp;#39;ve also
used that concept in developing other algorithms like the one I wrote
about &lt;a href=&#34;https://cestlaz.github.io/oldblog/2013-03-23-who_won_the_election-quadratic_to_linear_time/&#34;&gt;here&lt;/a&gt;. Assuming we&amp;#39;ve covered the ArrayList, We can easily code
up a sorting type algorithm (excuse any little Java errors, I&amp;#39;ve been
teaching this in C++ for the past 3 years):
&lt;/p&gt;
&lt;div class=&#34;src src-java&#34;&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;  ArrayList&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Integer&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;sort&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;ArrayList&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Integer&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; a&lt;span style=&#34;color:#f92672&#34;&gt;){&lt;/span&gt;
      ArrayList&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Integer&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; result &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; ArrayList&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
      &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; min_index&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;
      &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; value&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;
      &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; 0&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; a&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;length&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;i&lt;span style=&#34;color:#f92672&#34;&gt;++)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
          min_index &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; findMinIndex&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;a&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt;
          value &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; a&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;get&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;min_index&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt;
          a&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;remove&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;min_index&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt;
          result&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;append&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;value&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt;
      &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
      &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; result&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;
  &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;
This won&amp;#39;t be efficient due to &lt;a href=&#34;https://cestlaz.github.io/posts/2014-11-17-hidden-complexity/&#34;&gt;hidden complexity&lt;/a&gt; but it&amp;#39;s very easy to
write and understand the algorithm
&lt;/p&gt;
&lt;p&gt;
From here it&amp;#39;s a simple matter to code this algorithm in place -
swapping the next smallest item each time. This time coded with an array::
&lt;/p&gt;
&lt;div class=&#34;src src-java&#34;&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; min_index&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;
  &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; value&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;
  &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; 0&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; a&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;length&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;i&lt;span style=&#34;color:#f92672&#34;&gt;++)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
      min_index &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; findMinIndex&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;a&lt;span style=&#34;color:#f92672&#34;&gt;,&lt;/span&gt;1&lt;span style=&#34;color:#f92672&#34;&gt;,&lt;/span&gt;a&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;length&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;());&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;// find min excluding what&amp;#39;s sorted so far
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;      value &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; a&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;get&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;min_index&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt;
      swap&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;a&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;i&lt;span style=&#34;color:#f92672&#34;&gt;],&lt;/span&gt;a&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;min_index&lt;span style=&#34;color:#f92672&#34;&gt;]);&lt;/span&gt;
  &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;
If you want, you can then break out the findMinIndex routine and the
swap so that kids see all the code in one place but regardless, this
is an easy, incremental way of teaching selection sort.
&lt;/p&gt;
&lt;p&gt;
You can do something similar with insertion sort. Start with the code
to insert an item into an already sorted list. Write that as a routine
and then put a loop around it to complete the sort.
&lt;/p&gt;
&lt;p&gt;
Developing routines like this incrementally has a number of
advantages. The code is simpler, it reinforces old concepts, and it
gives students additional practice in composing more complex solutions
from building blocks.
&lt;/p&gt;
&lt;p&gt;
You can use a similar approach to coding the more advanced sorts but
I&amp;#39;ll save those ideas for a future post.
&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>A* is born</title>
      <link>https://cestlaz.github.io/posts/a-star-is-born/</link>
      <pubDate>Mon, 05 Jun 2017 00:00:00 +0000</pubDate>
      
      <guid>https://cestlaz.github.io/posts/a-star-is-born/</guid>
      <description>&lt;p&gt;
Over on the &lt;a href=&#34;https://cseducators.stackexchange.com/&#34;&gt;CS Educator StachExchange&lt;/a&gt;, which is in private beta for a
few more days, I saw a post asking about how to introduce the &lt;a href=&#34;https://en.wikipedia.org/wiki/A*_search_algorithm&#34;&gt;A*
search algorithm&lt;/a&gt;.
&lt;/p&gt;
&lt;p&gt;
I taught A* as part of the APCS class at Stuy so I thought I&amp;#39;d talk
about what I did here.
&lt;/p&gt;
&lt;p&gt;
Some time around mid year, we get to intermediate recursion. This is
about the time, give or take, when we talk about the nlogn sorts.
&lt;/p&gt;
&lt;p&gt;
We also build a recursive maze solver. It&amp;#39;s a nice algorithm and a
nice little program. It&amp;#39;s around 15 lines of code to perform a
recursive depth first search:
&lt;/p&gt;
&lt;img src=&#34;https://cestlaz.github.io/img/astar/dfs.gif&#34; alt=&#34;/img/astar/dfs.gif&#34; title=&#34;/img/astar/dfs.gif&#34; align=&#34;center&#34; height=&#34;200px&#34;/&gt;
&lt;p&gt;
The basic algorithm is:
&lt;/p&gt;
&lt;div class=&#34;src src-java&#34;&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;
It&amp;#39;s a nice lesson because in addition to all the recursion stuff, we
also get to talk about state space, state space search, backtracking,
efficiency concerns and much more. After we finish the maze solver, we also talk about
other problems that can be similarly examined using state-space search
like the knights tour and N-queens problems.
&lt;/p&gt;
&lt;p&gt;
A month or so later, when we&amp;#39;re learning about stacks and queues as
data structures, we revisit the maze solver. This time we solve the
problem in a more general way. We talk about using a data structure to
hold the set of nodes that we&amp;#39;re aware of and that we want to visit
next.
&lt;/p&gt;
&lt;div class=&#34;src src-java&#34;&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;
As we write the solution, we see that using a queue for this
data structure yields a breadth first search:
&lt;/p&gt;
&lt;img src=&#34;https://cestlaz.github.io/img/astar/bfs.gif&#34; alt=&#34;/img/astar/bfs.gif&#34; title=&#34;/img/astar/bfs.gif&#34; align=&#34;center&#34; height=&#34;200px&#34;/&gt;
&lt;p&gt;
while using a stack yields depth first.
&lt;/p&gt;
&lt;p&gt;
All of this leads to a discussion as to how deciding on which
locations to look at next can greatly influence the steps to the
exit. From here it&amp;#39;s easy to see that you can use a heuristic to order
the nodes in our data structure so that we explore &amp;#34;better&amp;#34;
possibilities first. The data structure becomes a priority queue and
we finally get to both &amp;#34;best first&amp;#34; and A* search:
&lt;/p&gt;
&lt;img src=&#34;https://cestlaz.github.io/img/astar/astar.gif&#34; alt=&#34;/img/astar/astar.gif&#34; title=&#34;/img/astar/astar.gif&#34; align=&#34;center&#34; height=&#34;200px&#34;/&gt;
&lt;p&gt;
It&amp;#39;s a nice sequence of lessons, albeit lessons spread out over
months. The end result is that the students see both the need and
motivation for something like A* and they see that it&amp;#39;s not hard to
implement. One basic routine where you can plug in one of three data
structures - stack, queue, or priority queue to get very different
results.
&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Sorting - Subtle Errors</title>
      <link>https://cestlaz.github.io/posts/2014-03-17-subtle-errors-sorting/</link>
      <pubDate>Mon, 17 Mar 2014 00:00:00 +0000</pubDate>
      
      <guid>https://cestlaz.github.io/posts/2014-03-17-subtle-errors-sorting/</guid>
      <description>&lt;!DOCTYPE html&gt;


&lt;style&gt;
div.center {text-align:center;}
&lt;/style&gt;

&lt;p&gt;
Time to wrap up sorting for a while. We just finished quicksort
having gone through a series of lessons
&lt;/p&gt;
&lt;ul class=&#34;org-ul&#34;&gt;
&lt;li&gt;We started with &lt;a href=&#34;http://cestlaz.github.io/2014/03/12/select-to-sort.html#.UyJRTh_G8RM&#34;&gt;Quickselect&lt;/a&gt;.
&lt;/li&gt;
&lt;li&gt;Then we did a quicksort, copying to new arrays during the partition
&lt;/li&gt;
&lt;li&gt;Then finally to an in place quicksort.
&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
For the final quicksort we used a partition algorithm pretty much the
same as the one described &lt;a href=&#34;http://en.wikipedia.org/wiki/Quicksort&#34;&gt;here.&lt;/a&gt;
&lt;/p&gt;

&lt;p&gt;
We started testing using by building a randomly filled array like this:
&lt;/p&gt;

&lt;div class=&#34;org-src-container&#34;&gt;

&lt;pre class=&#34;src src-java&#34;&gt;&lt;span style=&#34;color: #7CB8BB;&#34;&gt;Random&lt;/span&gt; &lt;span style=&#34;color: #DFAF8F;&#34;&gt;rnd&lt;/span&gt; = &lt;span style=&#34;color: #F0DFAF; font-weight: bold;&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color: #7CB8BB;&#34;&gt;Random&lt;/span&gt;();
&lt;span style=&#34;color: #7CB8BB;&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color: #DFAF8F;&#34;&gt;a&lt;/span&gt;[] = &lt;span style=&#34;color: #F0DFAF; font-weight: bold;&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color: #7CB8BB;&#34;&gt;int&lt;/span&gt;[n];
&lt;span style=&#34;color: #F0DFAF; font-weight: bold;&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color: #7CB8BB;&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color: #DFAF8F;&#34;&gt;i&lt;/span&gt;=0;i&amp;lt;&lt;span style=&#34;color: #7CB8BB;&#34;&gt;n&lt;/span&gt;;i++) {
a[i] = rnd.nextInt(100);
}
qsort(a);
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
And everything seemed terrific.
&lt;/p&gt;

&lt;p&gt;
Just like when we did the mergesort, we started to increase n. First
20, then 100, then 1000 and so on.
&lt;/p&gt;

&lt;p&gt;
All of a sudden, we started getting a stack overflow. We only made it
to about 450,000. Mergesort got to arrays of about 40,000,000 items
before we started to have memory problems.
&lt;/p&gt;

&lt;p&gt;
Our algorithm was sound. It worked on everything up to about
450,000. Since Mergesort worked well into the tens of millions, quicksort
should have as well.
&lt;/p&gt;

&lt;p&gt;
What was wrong?
&lt;/p&gt;

&lt;p&gt;
We changed the code a bit:
&lt;/p&gt;

&lt;div class=&#34;org-src-container&#34;&gt;

&lt;pre class=&#34;src src-java&#34;&gt;&lt;span style=&#34;color: #7CB8BB;&#34;&gt;Random&lt;/span&gt; &lt;span style=&#34;color: #DFAF8F;&#34;&gt;rnd&lt;/span&gt; = &lt;span style=&#34;color: #F0DFAF; font-weight: bold;&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color: #7CB8BB;&#34;&gt;Random&lt;/span&gt;();
&lt;span style=&#34;color: #7CB8BB;&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color: #DFAF8F;&#34;&gt;a&lt;/span&gt;[] = &lt;span style=&#34;color: #F0DFAF; font-weight: bold;&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color: #7CB8BB;&#34;&gt;int&lt;/span&gt;[n];
&lt;span style=&#34;color: #F0DFAF; font-weight: bold;&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color: #7CB8BB;&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color: #DFAF8F;&#34;&gt;i&lt;/span&gt;=0;i&amp;lt;&lt;span style=&#34;color: #7CB8BB;&#34;&gt;n&lt;/span&gt;;i++) {
a[i] = rnd.nextInt(10000);
}
qsort(a);
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
Instead of an array of 450,000 values between 0 and 100, our elements
now went fro 0 to 10,000.
&lt;/p&gt;

&lt;p&gt;
All of a sudden things were good.
&lt;/p&gt;

&lt;p&gt;
Why? It wasn&#39;t long before the student saw that 500,000 elements with
values between 0 and 100 meant lots of duplicates. Our partition
didn&#39;t account for that. If we had duplicate pivots, only one is moved
into place, the rest are left unsorted taking us closer to worst case
performance and blowing our stack.
&lt;/p&gt;

&lt;p&gt;
Fortunately there was an easy fix:
&lt;/p&gt;

&lt;div class=&#34;org-src-container&#34;&gt;

&lt;pre class=&#34;src src-java&#34;&gt;&lt;span style=&#34;color: #F0DFAF; font-weight: bold;&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color: #7CB8BB;&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color: #93E0E3;&#34;&gt;partition&lt;/span&gt;(&lt;span style=&#34;color: #7CB8BB;&#34;&gt;int&lt;/span&gt;[] &lt;span style=&#34;color: #DFAF8F;&#34;&gt;a&lt;/span&gt;, &lt;span style=&#34;color: #7CB8BB;&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color: #DFAF8F;&#34;&gt;l&lt;/span&gt;, &lt;span style=&#34;color: #7CB8BB;&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color: #DFAF8F;&#34;&gt;r&lt;/span&gt;) {
&lt;span style=&#34;color: #7CB8BB;&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color: #DFAF8F;&#34;&gt;tmp&lt;/span&gt;;
&lt;span style=&#34;color: #7CB8BB;&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color: #DFAF8F;&#34;&gt;pivotIndex&lt;/span&gt; = l+rnd.nextInt(r-l);
&lt;span style=&#34;color: #7CB8BB;&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color: #DFAF8F;&#34;&gt;pivot&lt;/span&gt; = a[pivotIndex];
tmp = a[r];
a[r] = a[pivotIndex];
a[pivotIndex]=tmp;

&lt;span style=&#34;color: #7CB8BB;&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color: #DFAF8F;&#34;&gt;wall&lt;/span&gt;=l;
&lt;span style=&#34;color: #7CB8BB;&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color: #DFAF8F;&#34;&gt;pcount&lt;/span&gt;=1;
&lt;span style=&#34;color: #F0DFAF; font-weight: bold;&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color: #7CB8BB;&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color: #DFAF8F;&#34;&gt;i&lt;/span&gt;=l;i&amp;lt;&lt;span style=&#34;color: #7CB8BB;&#34;&gt;r&lt;/span&gt;;i++) {
&lt;span style=&#34;color: #F0DFAF; font-weight: bold;&#34;&gt;if&lt;/span&gt; (a[i]&amp;lt;pivot) {
tmp = a[i];
a[i]=a[wall];
a[wall]=tmp;
wall++;
}
&lt;span style=&#34;color: #F0DFAF; font-weight: bold;&#34;&gt;if&lt;/span&gt; (a[i]==pivot)
pcount++;
}
&lt;span style=&#34;color: #5F7F5F;&#34;&gt;// &lt;/span&gt;&lt;span style=&#34;color: #7F9F7F;&#34;&gt;now copy over all the pivots&lt;/span&gt;
&lt;span style=&#34;color: #7CB8BB;&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color: #DFAF8F;&#34;&gt;rwall&lt;/span&gt;=wall;
tmp = a[rwall];
a[wall]=a[r];
a[r]=tmp;
rwall++;
&lt;span style=&#34;color: #F0DFAF; font-weight: bold;&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color: #7CB8BB;&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color: #DFAF8F;&#34;&gt;i&lt;/span&gt;=rwall+1;i&amp;lt;=r;i++) {
&lt;span style=&#34;color: #F0DFAF; font-weight: bold;&#34;&gt;if&lt;/span&gt; (a[i]==pivot) {
tmp = a[rwall];
a[rwall]=a[i];
a[i]=tmp;
rwall++;
}
}
&lt;span style=&#34;color: #F0DFAF; font-weight: bold;&#34;&gt;return&lt;/span&gt; (wall+rwall)/2;
}
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
When we partition the array, move all the elements equal to the
partition to the middle of the array.
&lt;/p&gt;


&lt;p&gt;
That did the trick.
&lt;/p&gt;

&lt;p&gt;
All of a sudden we were blazing through data sets upwards of
100,000,000 elements.
&lt;/p&gt;


&lt;p&gt;
We&#39;re done for sorting for a while, at least until the heapsort but
it&#39;s been a fun couple of weeks
&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>From selection to sorting</title>
      <link>https://cestlaz.github.io/posts/2014-03-12-select-to-sort/</link>
      <pubDate>Wed, 12 Mar 2014 00:00:00 +0000</pubDate>
      
      <guid>https://cestlaz.github.io/posts/2014-03-12-select-to-sort/</guid>
      <description>&lt;!DOCTYPE html&gt;

&lt;script type=&#34;text/javascript&#34; src=&#34;http://orgmode.org/mathjax/MathJax.js&#34;&gt;&lt;/script&gt;
&lt;script type=&#34;text/javascript&#34; src=&#34;assets/static/mj.js&#34;&gt;&lt;/script&gt;

&lt;style&gt;
div.center {text-align:center;}
&lt;/style&gt;

&lt;p&gt;
When I first saw the &lt;a href=&#34;http://en.wikipedia.org/wiki/Quicksort&#34;&gt;quicksort&lt;/a&gt; it was in an algorithms class back in
the day. We first learned the quicksort, then choosing a good pivot
element and then as an afterthought we did &lt;a href=&#34;http://en.wikipedia.org/wiki/Quickselect&#34;&gt;quickselect&lt;/a&gt;.
&lt;/p&gt;

&lt;p&gt;
Fast forward to teaching. I was never really happy teaching
quicksort. Mergesort is easy to motivate and it&#39;s pretty easy to
write. Quicksort always felt a little forced.
&lt;/p&gt;

&lt;p&gt;
I thought I&#39;d try switching things up this time and doing quickselect
first.
&lt;/p&gt;

&lt;p&gt;
The motivating problem: find the K&lt;sup&gt;th&lt;/sup&gt; smallest item in a list - in our
case the list is an array of ints.
&lt;/p&gt;

&lt;p&gt;
I want to start with the least efficient algorithm so I stack the
deck. I remind them that we&#39;ve been finding the smallest item in a
list for two years now.
&lt;/p&gt;

&lt;p&gt;
They don&#39;t disappoint and suggest something like this:
&lt;/p&gt;

&lt;div class=&#34;org-src-container&#34;&gt;

&lt;pre class=&#34;src src-python&#34;&gt;&lt;span style=&#34;color: #DFAF8F;&#34;&gt;L&lt;/span&gt; = [10,3,28,82,14,42,66,74,81]

&lt;span style=&#34;color: #F0DFAF; font-weight: bold;&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color: #93E0E3;&#34;&gt;findKth&lt;/span&gt;(L,k):
&lt;span style=&#34;color: #DFAF8F;&#34;&gt;omits&lt;/span&gt;=[]
&lt;span style=&#34;color: #F0DFAF; font-weight: bold;&#34;&gt;for&lt;/span&gt; i &lt;span style=&#34;color: #F0DFAF; font-weight: bold;&#34;&gt;in&lt;/span&gt; &lt;span style=&#34;color: #DCDCCC; font-weight: bold;&#34;&gt;range&lt;/span&gt;(k):
&lt;span style=&#34;color: #DFAF8F;&#34;&gt;ans&lt;/span&gt;=&lt;span style=&#34;color: #DCDCCC; font-weight: bold;&#34;&gt;max&lt;/span&gt;(L)
&lt;span style=&#34;color: #F0DFAF; font-weight: bold;&#34;&gt;for&lt;/span&gt; item &lt;span style=&#34;color: #F0DFAF; font-weight: bold;&#34;&gt;in&lt;/span&gt; L:
&lt;span style=&#34;color: #F0DFAF; font-weight: bold;&#34;&gt;if&lt;/span&gt; item &amp;lt; ans &lt;span style=&#34;color: #F0DFAF; font-weight: bold;&#34;&gt;and&lt;/span&gt; item &lt;span style=&#34;color: #F0DFAF; font-weight: bold;&#34;&gt;not&lt;/span&gt; &lt;span style=&#34;color: #F0DFAF; font-weight: bold;&#34;&gt;in&lt;/span&gt; omits:
&lt;span style=&#34;color: #DFAF8F;&#34;&gt;ans&lt;/span&gt;=item
omits.append(ans)
&lt;span style=&#34;color: #F0DFAF; font-weight: bold;&#34;&gt;return&lt;/span&gt; ans

&lt;span style=&#34;color: #F0DFAF; font-weight: bold;&#34;&gt;print&lt;/span&gt; findKth(L,3)
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
Clearly an \(O(n^2)\) algorithm.
&lt;/p&gt;


&lt;p&gt;
Can we do better?
&lt;/p&gt;

&lt;p&gt;
Certainly.
&lt;/p&gt;

&lt;p&gt;
The students then suggest sorting the data set first. If we use
mergesort, we can sort in \(O(nLg (n))\) time. This lead to a great
conversation about sorting being so fast it&#39;s practically free and
that you don&#39;t have to hard code everything from scratch. Not only is
sorting the data set then plucking the k&lt;sup&gt;th&lt;/sup&gt; item out much faster, if
you already have a sort written or if you use your language&#39;s
library&#39;s sort, it&#39;s much easier as well:
&lt;/p&gt;

&lt;div class=&#34;org-src-container&#34;&gt;

&lt;pre class=&#34;src src-python&#34;&gt;&lt;span style=&#34;color: #F0DFAF; font-weight: bold;&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color: #93E0E3;&#34;&gt;findKth&lt;/span&gt;(L,k):
&lt;span style=&#34;color: #DFAF8F;&#34;&gt;tmp&lt;/span&gt; = &lt;span style=&#34;color: #DCDCCC; font-weight: bold;&#34;&gt;sorted&lt;/span&gt;(L)
&lt;span style=&#34;color: #F0DFAF; font-weight: bold;&#34;&gt;return&lt;/span&gt; tmp[k]
&lt;/pre&gt;
&lt;/div&gt;


&lt;p&gt;
But we can do even better. So now we talk about &lt;b&gt;quickselect&lt;/b&gt;
&lt;/p&gt;

&lt;p&gt;
We pick a random pivot, partition the list a la quicksort (reorder the
list such that all items less than the pivot are to its left, and all
items greater than the pivot are to its right).
&lt;/p&gt;

&lt;p&gt;
We now know that after partitioning. the pivot is in it&#39;s exact
location. If its index is &lt;b&gt;k&lt;/b&gt; then we&#39;re done. If not, we can
recursively &lt;b&gt;quickselect&lt;/b&gt; on either the left or right side.
&lt;/p&gt;

&lt;p&gt;
Pretty cool, but is it faster?
&lt;/p&gt;

&lt;p&gt;
It&#39;s easy to see that if we keep choosing a bad pivot (the smallest or
largest in the list), each iteration takes \(n\) time to partition and
each iteration takes one item out of contention. This takes us back to
\(O(n^2)\).
&lt;/p&gt;

&lt;p&gt;
However&amp;#x2026;
&lt;/p&gt;

&lt;p&gt;
If we choose a good partition &amp;#x2013; at the middle of the list, each
partition takes less and less time. We get a run time of:
&lt;/p&gt;

&lt;p&gt;
\(n+\frac{n}{2} +\frac{n}{4}+\frac{n}{8}+\dots\) and since \(\frac{n}{2}
+\frac{n}{4}+\frac{n}{8}\dots=n\) this becomes an \(O(2n)\), or \(O(n)\) algorithm.
&lt;/p&gt;


&lt;p&gt;
That&#39;s really cool.
&lt;/p&gt;

&lt;p&gt;
Homework was the actual implementation.
&lt;/p&gt;

&lt;p&gt;
I think this might be a better way to approach quicksort. It seems
less forced, plus the class gets to go through the exercise of taking
an algorithm form \(O(n^2)\) to \(O(nlg(n))\) to \(O(n)\).
&lt;/p&gt;


&lt;p&gt;
Next, moving to the quicksort and also showing that we can indeed
avoid those really bad pivots.
&lt;/p&gt;


&lt;h4&gt;Addendum&lt;/h4&gt;

We moved to quicksort today and overall I&#39;m happy with this
approach. The only thing I think needs tweaking is going from the idea
of partitioning to Java code. Java makes it somewhat of a bear.
&lt;br&gt;
</description>
    </item>
    
    <item>
      <title>I guess I&#39;m a dumbass</title>
      <link>https://cestlaz.github.io/posts/2014-02-27-dumbass/</link>
      <pubDate>Thu, 27 Feb 2014 00:00:00 +0000</pubDate>
      
      <guid>https://cestlaz.github.io/posts/2014-02-27-dumbass/</guid>
      <description>&lt;p&gt;I like a fairly informal atmosphere in my classes. Students have to
know that there&amp;rsquo;s a line between teacher and student but I also want
them to feel like we&amp;rsquo;re all part of the Stuy CS family.&lt;/p&gt;
&lt;p&gt;Whenever we start a new term, it takes a while to break down the
walls. The students don&amp;rsquo;t know what to expect of me, can they trust
me? Am I a bozo? Who knows.&lt;/p&gt;
&lt;p&gt;It helps when some of the class had me as a teacher before, but it still takes time.&lt;/p&gt;
&lt;p&gt;I&amp;rsquo;m glad that this term, things are coming along nicely.&lt;/p&gt;
&lt;p&gt;Let me share what happened in class today.&lt;/p&gt;
&lt;p&gt;I was introducing merge sort - their first nlgn sorting
algorithm. Before class, one of the students slipped off his seat and landed on the floor with a thud. He
was fine although the brief butt, if you would, of jokes.&lt;/p&gt;
&lt;p&gt;I relayed a story - many years ago, Ilya, one of the gang, was accused
of being a dumbass. He responded &amp;ldquo;hey, it&amp;rsquo;s never missed the seat.&amp;rdquo; The
class had a good laugh over it.&lt;/p&gt;
&lt;p&gt;Fast forward a bit.&lt;/p&gt;
&lt;p&gt;I had a deck of cards I wanted sorted. As a Stuy grad, I&amp;rsquo;m as lazy as
the next guy so I didn&amp;rsquo;t want to sort them, but I also didn&amp;rsquo;t want to
violate one of our two class tenets &amp;ldquo;Don&amp;rsquo;t be a jerk&amp;rdquo; so rather than
giving the cards to a student to sort, I split the deck in half and
gave each half to a student.&lt;/p&gt;
&lt;p&gt;They quickly caught on and subdivided the deck and gave away their
halves. We did this until all the students had, at some point had one
or more cards.&lt;/p&gt;
&lt;p&gt;Then we got to the merge part. Each student sorted his or her pile and
passed it back to the student who they got the cards from. This
student then merged the two piles and passed the cards back.&lt;/p&gt;
&lt;p&gt;As the cards made their way back to me a student noted &amp;ldquo;hey, one of my
piles isn&amp;rsquo;t in order.&amp;rdquo; I commented that &amp;ldquo;the algorithm might fail if
at some points you give your cards to a dumbass.&amp;rdquo; This got a good
laugh.&lt;/p&gt;
&lt;p&gt;Finally, two pile of cards made their way to me and I started to merge
then. At which point, I promptly dropped the cards all over the floor.&lt;/p&gt;
&lt;p&gt;One of my students exclaimed: &amp;ldquo;That&amp;rsquo;s what happens when you give you
cards to a dumbass!!!!!&amp;rdquo;&lt;/p&gt;
&lt;p&gt;It was awesome. We all cracked up.&lt;/p&gt;
&lt;p&gt;I don&amp;rsquo;t think I&amp;rsquo;ve been &amp;ldquo;insulted&amp;rdquo; quite so perfectly since my daughter
called me an idiot in class last year (I fed her the straight line and
she didn&amp;rsquo;t disappoint).&lt;/p&gt;
&lt;p&gt;I love it that my kids feel comfortable enough to joke but also know
where the line is.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Fibonacci by the tail</title>
      <link>https://cestlaz.github.io/posts/2014-02-13-fibonacci/</link>
      <pubDate>Thu, 13 Feb 2014 00:00:00 +0000</pubDate>
      
      <guid>https://cestlaz.github.io/posts/2014-02-13-fibonacci/</guid>
      <description>&lt;p&gt;We&amp;rsquo;re ramping up for recursion in my junior classes - state space
search, nlg(n) sorts, etc. As a refresher, we took a quick look at the
Fibonacci numbers.&lt;/p&gt;
&lt;p&gt;Now, some people seem to think that it&amp;rsquo;s a tired problem. It&amp;rsquo;s mathy,
it&amp;rsquo;s played out, it&amp;rsquo;s boring etc.. They just might be missing the
point.&lt;/p&gt;
&lt;p&gt;The beauty isn&amp;rsquo;t in the problem itself, but rather, that it&amp;rsquo;s a
platform on which you can look at many problem solving techniques.&lt;/p&gt;
&lt;p&gt;We can look at the basic, straightforward , imperative solution:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;fib1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; n&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; a&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;1&lt;span style=&#34;color:#f92672&#34;&gt;,&lt;/span&gt;b&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;1&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; i&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;0&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;i&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;n&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;i&lt;span style=&#34;color:#f92672&#34;&gt;++){&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; c&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;a&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;b&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;
a&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;b&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;
b&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;c&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; a&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;It&amp;rsquo;s straightforward and fast - no recursion needed.&lt;/p&gt;
&lt;p&gt;Next, we can look at the basic recursive version:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;fib2&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; n&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;n&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt;1&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; 1&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; fib2&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;n&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;1&lt;span style=&#34;color:#f92672&#34;&gt;)+&lt;/span&gt;fib2&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;n&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;2&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The advantages (of recursive solutions in general):&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;It&amp;rsquo;s a direct translation from the recursive mathematical formula.&lt;/li&gt;
&lt;li&gt;It&amp;rsquo;s elegant, clean, and concise.&lt;/li&gt;
&lt;li&gt;It can make hard problems much easier (see: &lt;a href=&#34;http://cestlaz.github.io/2010/01/10/towers-of-hanoi.html#.Uv1m4N_EvZ8&#34;&gt;Towers, Hanoi&lt;/a&gt;).&lt;/li&gt;
&lt;li&gt;We can use same thought process that led to this solution to solve
problems like finding our way out of a maze.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The downside:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;It can be VERY slow.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;So, how do we address this?&lt;/p&gt;
&lt;p&gt;One way is via &lt;strong&gt;memoization&lt;/strong&gt; - when we find a value, store it in a
table, then we can use the look up table instead of recalculating over
and over:&lt;/p&gt;
&lt;blockquote&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/blockquote&gt;
&lt;p&gt;public int[] fibnums = new int[100000];
public int fib3(int n) {
if (n&amp;lt;=1)
return 1;
else if (fibnums[n] != 0)
return fibnums[n];
else {
fibnums[n] fib3(n-1)+fib3(n-2);
return fibnums[n];
}
}&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
This is a terrific thing to show a class since it&#39;s easy for students
to wrap their heads around, it really speeds things up, and it&#39;s a
precursor to lots of neat algorithms.

Finally, we can look at re-writing Fibonacci using tail
recursion. This one can be a little hard for students to grasp. I like
building it up from the iterative solution. In that solution, we use
**a**, and **b** to &amp;quot;walk down&amp;quot; the list of Fibonacci numbers. At any point in time, **a** and **b** represent where we are in the sequence. We also use **c** but that&#39;s really just a temporary place to add a and b together.

The problem with doing this in a recursive solution is that we can&#39;t
have **a** and **b** as local variables as each recursive call will
have new **a** and **b**s and no information will be transferred.

Since we&#39;re working in Java, it doesn&#39;t take long for some students to come up with the idea of using instance variables to store a and b and just use the recursion for the &amp;quot;loop.&amp;quot;:

&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; a&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;1&lt;span style=&#34;color:#f92672&#34;&gt;,&lt;/span&gt; b&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;1
&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;fib4&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; n&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;n&lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt;1&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; a&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; c&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;a&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;b&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;
a&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;b&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;
b&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;c&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; fib4&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;n&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;1&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


Great, but using instance variables in this way is very inelegant and messy. Better, use extra parameters to store the values from call to call:

&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;fib5&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; n&lt;span style=&#34;color:#f92672&#34;&gt;,&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; a&lt;span style=&#34;color:#f92672&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; b&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;n&lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt;1&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; a&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; fib4&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;n&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;1&lt;span style=&#34;color:#f92672&#34;&gt;,&lt;/span&gt;b&lt;span style=&#34;color:#f92672&#34;&gt;,&lt;/span&gt;a&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;b&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

Looking at Fib5(5) we get for n, a, and b:

* 5,1,1
* 4 1,2
* 3,2,3
* 2,3,5
* 1,5,8

At which point we just return the 8

Clean, elegant, fast, and easy to understand.

Each of these four techniques are important and will be used time and time again and here we have one simple problem that allows us to explore them all.

#### Some Links

[Project Euler: Problem #2 - Even Fibonacci numbers](http://maikolsolis.wordpress.com/2014/01/18/project-euler-problem-2-even-fibonacci-numbers/)

[Memoized Fibonacci Numbers with Java 8](http://java.dzone.com/articles/memoized-fibonacci-numbers)

[The quadratic formula and Fibonacci numbers](http://mikesmathpage.wordpress.com/2014/02/07/the-quadratic-formula-and-fibonacci-numbers/)

[Monte Carlo Simulations, Fibonacci Numbers, and Other Number Tests: Why Developers Still Need The Basics](http://blog.smartbear.com/programming/why-developers-
still-need-the-basics/)

[TED: Arthur Benjamin: The magic of Fibonacci numbers - Arthur Benjamin (2013)](http://www.ted.com/talks/arthur_benjamin_the_magic_of_fibonacci_numbers.html)

[Fibonacci Numbers in the Real World](http://lee-phillips.org/lispmath/)
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>Sorting from the top and from the bottom</title>
      <link>https://cestlaz.github.io/posts/2010-03-14-sorting-from-top-and-from-bottom/</link>
      <pubDate>Sun, 14 Mar 2010 00:00:00 +0000</pubDate>
      
      <guid>https://cestlaz.github.io/posts/2010-03-14-sorting-from-top-and-from-bottom/</guid>
      <description>&lt;!DOCTYPE html&gt;

&lt;div id=&#34;content&#34;&gt;&lt;h1 class=&#34;title&#34;&gt;Sorting from the top and from the bottom&lt;/h1&gt; &lt;p&gt;I&#39;ve been meaning to write this post for a couple of weeks, but some times life just gets in the way. &lt;/p&gt;&lt;p&gt;I&#39;ve always thought it important to arm students with as many different tools with which to attack problems as possible. As such, the courses I teach use a number of different languages, each highlighting a different paradigm and thought process. The hope is that by the end of the sequence, they can look at problems from many different angles. &lt;/p&gt;&lt;p&gt;In my advanced placement classes, we recently studied sorting algorithms.  It think the quicksort is a good example of a problem that can be looked at from multiple points of view. &lt;/p&gt;&lt;p&gt;In my experiences talking to teachers and students who cut there teeth using languages like Java, C, or C++, much of the discussion deals with the actual partitioning of the array. Comparing elements, swapping them and arriving in the middle. One might end up with something like this as a first cut: &lt;/p&gt;   &lt;pre class=&#34;src src-java&#34;&gt;&lt;br /&gt;&lt;span class=&#34;linenr&#34;&gt; 1:  &lt;/span&gt;&lt;span style=&#34;color: #a020f0;&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color: #228b22;&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color: #0000ff;&#34;&gt;qsort&lt;/span&gt;(&lt;span style=&#34;color: #228b22;&#34;&gt;int&lt;/span&gt;[] &lt;span style=&#34;color: #a0522d;&#34;&gt;a&lt;/span&gt;,&lt;span style=&#34;color: #228b22;&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color: #a0522d;&#34;&gt;l&lt;/span&gt;, &lt;span style=&#34;color: #228b22;&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color: #a0522d;&#34;&gt;h&lt;/span&gt;)&lt;br /&gt;&lt;span class=&#34;linenr&#34;&gt; 2:  &lt;/span&gt;{&lt;br /&gt;&lt;span class=&#34;linenr&#34;&gt; 3:  &lt;/span&gt;&lt;span style=&#34;color: #a020f0;&#34;&gt;if&lt;/span&gt; (l&amp;gt;=h)&lt;br /&gt;&lt;span class=&#34;linenr&#34;&gt; 4:  &lt;/span&gt;  &lt;span style=&#34;color: #a020f0;&#34;&gt;return&lt;/span&gt;;&lt;br /&gt;&lt;span class=&#34;linenr&#34;&gt; 5:  &lt;/span&gt;&lt;br /&gt;&lt;span class=&#34;linenr&#34;&gt; 6:  &lt;/span&gt;&lt;span style=&#34;color: #b22222;&#34;&gt;/* &lt;/span&gt;&lt;span style=&#34;color: #b22222;&#34;&gt;Just use lowest index as pivot for now */&lt;/span&gt;&lt;br /&gt;&lt;span class=&#34;linenr&#34;&gt; 7:  &lt;/span&gt;&lt;span style=&#34;color: #228b22;&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color: #a0522d;&#34;&gt;pivot&lt;/span&gt; = a[l];&lt;br /&gt;&lt;span class=&#34;linenr&#34;&gt; 8:  &lt;/span&gt;&lt;span style=&#34;color: #228b22;&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color: #a0522d;&#34;&gt;low&lt;/span&gt;=l;&lt;br /&gt;&lt;span class=&#34;linenr&#34;&gt; 9:  &lt;/span&gt;&lt;span style=&#34;color: #228b22;&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color: #a0522d;&#34;&gt;high&lt;/span&gt;=h;&lt;br /&gt;&lt;span class=&#34;linenr&#34;&gt;10:  &lt;/span&gt;&lt;br /&gt;&lt;span class=&#34;linenr&#34;&gt;11:  &lt;/span&gt;&lt;span style=&#34;color: #b22222;&#34;&gt;/* &lt;/span&gt;&lt;span style=&#34;color: #b22222;&#34;&gt;partition the data set around the pivot value */&lt;/span&gt;&lt;br /&gt;&lt;span class=&#34;linenr&#34;&gt;12:  &lt;/span&gt;&lt;span style=&#34;color: #a020f0;&#34;&gt;while&lt;/span&gt; (l&amp;lt;=h)&lt;br /&gt;&lt;span class=&#34;linenr&#34;&gt;13:  &lt;/span&gt;{&lt;br /&gt;&lt;span class=&#34;linenr&#34;&gt;14:  &lt;/span&gt;  &lt;span style=&#34;color: #a020f0;&#34;&gt;while&lt;/span&gt; (a[l]&amp;lt;pivot)&lt;br /&gt;&lt;span class=&#34;linenr&#34;&gt;15:  &lt;/span&gt;    l++;&lt;br /&gt;&lt;span class=&#34;linenr&#34;&gt;16:  &lt;/span&gt;  &lt;span style=&#34;color: #a020f0;&#34;&gt;while&lt;/span&gt; (a[h]&amp;gt;pivot)&lt;br /&gt;&lt;span class=&#34;linenr&#34;&gt;17:  &lt;/span&gt;    h--;&lt;br /&gt;&lt;span class=&#34;linenr&#34;&gt;18:  &lt;/span&gt;  &lt;span style=&#34;color: #a020f0;&#34;&gt;if&lt;/span&gt; (l&amp;lt;=h)&lt;br /&gt;&lt;span class=&#34;linenr&#34;&gt;19:  &lt;/span&gt;  {&lt;br /&gt;&lt;span class=&#34;linenr&#34;&gt;20:  &lt;/span&gt;    &lt;span style=&#34;color: #228b22;&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color: #a0522d;&#34;&gt;tmp&lt;/span&gt;=a[l];&lt;br /&gt;&lt;span class=&#34;linenr&#34;&gt;21:  &lt;/span&gt;    a[l]=a[h];&lt;br /&gt;&lt;span class=&#34;linenr&#34;&gt;22:  &lt;/span&gt;    a[h]=tmp;&lt;br /&gt;&lt;span class=&#34;linenr&#34;&gt;23:  &lt;/span&gt;    l++;&lt;br /&gt;&lt;span class=&#34;linenr&#34;&gt;24:  &lt;/span&gt;    h--; &lt;br /&gt;&lt;span class=&#34;linenr&#34;&gt;25:  &lt;/span&gt;  }&lt;br /&gt;&lt;span class=&#34;linenr&#34;&gt;26:  &lt;/span&gt;}&lt;br /&gt;&lt;span class=&#34;linenr&#34;&gt;27:  &lt;/span&gt;&lt;br /&gt;&lt;span class=&#34;linenr&#34;&gt;28:  &lt;/span&gt;&lt;span style=&#34;color: #b22222;&#34;&gt;/* &lt;/span&gt;&lt;span style=&#34;color: #b22222;&#34;&gt;sort items below and above the pivot */&lt;/span&gt;&lt;br /&gt;&lt;span class=&#34;linenr&#34;&gt;29:  &lt;/span&gt;qsort(a,low,l-1);&lt;br /&gt;&lt;span class=&#34;linenr&#34;&gt;30:  &lt;/span&gt;qsort(a,l,high);&lt;br /&gt;&lt;span class=&#34;linenr&#34;&gt;31:  &lt;/span&gt;&lt;br /&gt;&lt;span class=&#34;linenr&#34;&gt;32:  &lt;/span&gt;}&lt;br /&gt;&lt;/pre&gt;    &lt;p&gt;A fair amount of time and detail is spent dealing with the low level movement of data within the array . This is important &amp;ndash; good stuff, but it takes the emphasis away from the higher level elegance of the algorithm. &lt;/p&gt;&lt;p&gt;The quicksort can be described as: &lt;/p&gt;  &lt;ol&gt;&lt;li&gt; If the size of the list is &lt;= 1, return.&lt;/li&gt;&lt;li&gt;&lt;ol&gt;&lt;li&gt; Select a pivot element&lt;/li&gt;&lt;li&gt; Generate the list L of items smaller than the pivot&lt;/li&gt;&lt;li&gt; Generate the list H of items larger than the pivot&lt;/li&gt;&lt;li&gt; the sorted list is qsort(L)+pivot+qsort(R)&lt;/li&gt;&lt;/ol&gt;&lt;/ol&gt; &lt;p&gt;Having seen some scheme in their intro class, our students have a tool with which we can describe the quicksort in terms much closer to the description (allowing for the fact that this doesn&#39;t deal with multiple values equal to the pivot correctly): &lt;/p&gt;    &lt;pre class=&#34;src src-scheme&#34;&gt;&lt;br /&gt;&lt;span class=&#34;linenr&#34;&gt; 1:  &lt;/span&gt;(&lt;span style=&#34;color: #a020f0;&#34;&gt;define&lt;/span&gt; &lt;span style=&#34;color: #0000ff;&#34;&gt;makefilter&lt;/span&gt;&lt;br /&gt;&lt;span class=&#34;linenr&#34;&gt; 2:  &lt;/span&gt;  (&lt;span style=&#34;color: #a020f0;&#34;&gt;lambda&lt;/span&gt; (op x)&lt;br /&gt;&lt;span class=&#34;linenr&#34;&gt; 3:  &lt;/span&gt;    (&lt;span style=&#34;color: #a020f0;&#34;&gt;lambda&lt;/span&gt; (n) (op x n))))&lt;br /&gt;&lt;span class=&#34;linenr&#34;&gt; 4:  &lt;/span&gt;&lt;br /&gt;&lt;span class=&#34;linenr&#34;&gt; 5:  &lt;/span&gt;(&lt;span style=&#34;color: #a020f0;&#34;&gt;define&lt;/span&gt; &lt;span style=&#34;color: #0000ff;&#34;&gt;qsort&lt;/span&gt; &lt;br /&gt;&lt;span class=&#34;linenr&#34;&gt; 6:  &lt;/span&gt;  (&lt;span style=&#34;color: #a020f0;&#34;&gt;lambda&lt;/span&gt; (l)&lt;br /&gt;&lt;span class=&#34;linenr&#34;&gt; 7:  &lt;/span&gt;    (&lt;span style=&#34;color: #a020f0;&#34;&gt;cond&lt;/span&gt; ((null? l) &#39;())&lt;br /&gt;&lt;span class=&#34;linenr&#34;&gt; 8:  &lt;/span&gt;          (&lt;span style=&#34;color: #a020f0;&#34;&gt;else&lt;/span&gt; (append (qsort (filter (makefilter &amp;gt; (car l)) l))&lt;br /&gt;&lt;span class=&#34;linenr&#34;&gt; 9:  &lt;/span&gt;                        (list (car l))&lt;br /&gt;&lt;span class=&#34;linenr&#34;&gt;10:  &lt;/span&gt;                        (qsort (filter (makefilter &amp;lt; (car l)) l)))))))&lt;br /&gt;&lt;/pre&gt;    &lt;p&gt;This allows us to discuss the quicksort at a much higher level and focus on things like selecting a good pivot or the analysis of the run time. I believe this makes it much easier to really understand what&#39;s going on. &lt;/p&gt;&lt;p&gt;Having discussed it in this functional context, we can also look at the same thing in a scripting language such as python: &lt;/p&gt;   &lt;pre class=&#34;src src-python&#34;&gt;&lt;br /&gt;&lt;span class=&#34;linenr&#34;&gt;1:  &lt;/span&gt;&lt;span style=&#34;color: #a020f0;&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color: #0000ff;&#34;&gt;qsort&lt;/span&gt;(l):&lt;br /&gt;&lt;span class=&#34;linenr&#34;&gt;2:  &lt;/span&gt;    &lt;span style=&#34;color: #a020f0;&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color: #a020f0;&#34;&gt;len&lt;/span&gt;(l)&amp;lt;=1:&lt;br /&gt;&lt;span class=&#34;linenr&#34;&gt;3:  &lt;/span&gt;        &lt;span style=&#34;color: #a020f0;&#34;&gt;return&lt;/span&gt; l&lt;br /&gt;&lt;span class=&#34;linenr&#34;&gt;4:  &lt;/span&gt;    &lt;span style=&#34;color: #a020f0;&#34;&gt;else:&lt;/span&gt;&lt;br /&gt;&lt;span class=&#34;linenr&#34;&gt;5:  &lt;/span&gt;        &lt;span style=&#34;color: #a020f0;&#34;&gt;return&lt;/span&gt; qsort([x &lt;span style=&#34;color: #a020f0;&#34;&gt;for&lt;/span&gt; x &lt;span style=&#34;color: #a020f0;&#34;&gt;in&lt;/span&gt; l[1:] &lt;span style=&#34;color: #a020f0;&#34;&gt;if&lt;/span&gt; x &amp;lt;= l[0]]) + [l[0]]+\&lt;br /&gt;&lt;span class=&#34;linenr&#34;&gt;6:  &lt;/span&gt;            qsort([x &lt;span style=&#34;color: #a020f0;&#34;&gt;for&lt;/span&gt; x &lt;span style=&#34;color: #a020f0;&#34;&gt;in&lt;/span&gt; l[1:] &lt;span style=&#34;color: #a020f0;&#34;&gt;if&lt;/span&gt; x &amp;gt; l[0]])&lt;br /&gt;&lt;span class=&#34;linenr&#34;&gt;7:  &lt;/span&gt;&lt;br /&gt;&lt;/pre&gt;    &lt;p&gt;Again, the focus is on the algorithm, not the array or list manipulation. &lt;/p&gt;&lt;p&gt;Looking at the problem from both the more abstract side, which in this case functional languages allow, and the more concrete, as we did in Java gives our students more tools with which to attack problems. &lt;/p&gt;&lt;p&gt;Just some food for thought. &lt;/p&gt;       &lt;/div&gt;&lt;div class=&#34;blogger-post-footer&#34;&gt;&lt;img width=&#39;1&#39; height=&#39;1&#39; src=&#39;https://blogger.googleusercontent.com/tracker/468689896075458340-2070280110494147035?l=cestlaz.blogspot.com&#39; alt=&#39;&#39; /&gt;&lt;/div&gt;
</description>
    </item>
    
  </channel>
</rss>